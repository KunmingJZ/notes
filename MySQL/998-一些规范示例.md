```
命名
 库名、表名、字段名必须使用小写字母,并采用下划线分割
MySQL有配置参数lower_case_table_names,不可动态更改,linux系统默认为0,即库表名以实际情况存储,大小写敏感。如果是1,以小写存储,大小写不敏感。如果是2,以实际情况存储,但以小写比较
如果大小写混合使用,可能存在abc,Abc,ABC等多个表共存,容易导致混乱。
字段名显式区分大小写,但实际使用不区分,即不可以建立两个名字一样但大小写不一样的字段。
为了统一规范, 库名、表名、字段名使用小写字母。
库名、表名、字段名禁止超过32个字符
库名、表名、字段名支持最多64个字符,但为了统一规范、易于辨识以及减少传输量,禁止超过32个字符。
库名、表名、字段名禁止使用MySQL保留字
命名应具有实际意义，统一为一种语言。表名无需数据库名称前缀。如:aas系统表aas_act_param，建议名称为：t_act_param
          
表
原则上，业务范畴内的表都统一使用InnoDB存储引擎,MyISAM可以完全淘汰；如需使用其它存储引擎，需说明原因，并经过评审决定。
日志之类的大表可以考虑采用TokuDB引擎，相对InnoDB，有更高的写入速度，数据压缩最高可达40：1，能够节约大量的磁盘空间。TokuDB引擎MySQL自带的存储引擎，需要单独配置部署，同时数据备份方案也需要相应调整。
尽量不要使用分区表，如要使用，需说明原因，并经过评审决定，分区表对分区键有严格要求;分区表在表变大后,执行DDL、SHARDING、单表恢复等都变得更加困难。因此禁止使用分区表,并建议业务端手动SHARDING。
减少或避免使用临时表，每个表都要加上comment标明用途。
为了切换后可以正常工作，无论主备，相同的表需使用相同的引擎，需要严格保持主备数据和表结构的一致性。
每一个表都需要设置主键，并且需要有业务唯一键
表没有主键,InnoDB会默认设置隐藏的主键列;没有主键的表在定位数据行的时候非常困难,也会降低基于行复制的效率。
每个表都需要有业务唯一键，避免业务数据重复。
将大字段、访问频率低的字段拆分到单独的表中存储,分离冷热数据
所有表默认使用utf8、utf8mb4字符集
 为跟踪业务数据的更改变化，要求业务关键数据TABLE中必须包含以下特定的WHO字段：
          
范式
表不要求一定满足第三范式，根据实际情况可适当添加冗余字段
原则是一个SQL最好只操作一个表，最多不能超过2个表的关联。如果实现一个常用的功能需要一个关联多表的查询，则需要重新考虑设计。
由程序保证冗余数据的维护 
字段
对于字段设计，概括下来一个原则是：越简单越好，越小越好
 
 选择最合适的数据类型
能用数字类型不用varchar类型；
能用date/datetime类型不用varchar类型；
非字长，避免使用char类型；
不使用浮点数，可以通过乘以一个系数来转换为整型数据。
大部分情况下，数字类型比varchar类型更省空间，计算性能更高。
char类型占用固定空间，在很多时候会造成空间浪费。
尽量避免text/lob类型，如果一定要存储长文本，优先text.
text和lob在行内只存储指针，实际数据是在行外单独存储的。使用这些数据类型，查询时需要更多的IO。
如果SQL引用了text/lob字段，排序等操作需要用到隐式临时表时，只能用到disk临时表，不能用in-memory临时表。对性能影响巨大。
如果需要用text/lob类型，建议把这些字段和其他字段分离，放在单独的表中。
字段长度定义遵循最小化原则，够用就行，不能贪图方便定义很大的长度
字段实际值也遵循最小化原则，在满足业务需求的前提下，选择最合适的数据类型，写入最少的数据
ID采用业务主键，优先使用数字来用于ID字段，杜绝滥用长字符串ID。
对于状态之类的字段，用0/1之类的数字代替valid/invalid等。
使用TIMESTAMP的自动赋值属性
自动初始化,并自动更新: column1 TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
只是自动初始化: column1 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
一个表的字段个数控制在30-50个字段以内；如果字段超过50个，可考虑将字段按冷热程度分表。
严格禁止单条记录超过8K
每一个重要的业务表必须都加上create_datetime和update_datetime两个字段，数据类型为timestamp
对于可能出现在where条件中的字段，尽量设置为非空(not null)
字段字符集与表保持一致，不单独设置字符集和校验集，列要用comment标注用途。
相同含义的字段在不同表中应使用相同的名称，数据类型及长度必须保持一致。
索引
InnoDB表每一个表都要设置主键
主键越短越好，尽量使用业务主键，考虑构造使用单向递增型主键，禁止使用随机类型值用于主键。
使用InnoDB，每一个表都必须有主键。如果没有指定主键，MySQL会选择一个非空的唯一键作为主键；如果都没有，MySQL会自动分配6-bytes长的全局的rowid隐藏列作为主键。所有InnoDB非主键表共享这一序列，并发性能较差，因此建议所有InnoDB表，指定主键。
所有的辅助索引都包含主键字段，因此，如果主键过大的话，会影响所有的索引大小。
递增型主键可以让索引更紧凑、空间利用更充分、数据插入更高效。随机数据会让空间大量浪费，且会导致索引分裂加剧，离散IO增多，极大影响DML性能。
主键最好由一个字段构成，最多不要超过3个，禁止超过3个字段的组合主键
如果一个业务上存在多个(组)唯一键，以查询最常用的唯一键作为主键
选择作为主键的列必须在插入后不再修改或者极少修改。
创建组合索引/主键时，常用的字段放在前面；选择性高的字段放在前面,两者冲突时，以常用为更优先选择。
创建组合索引时，如果where条件中过滤性不强，且需要排序分页操作，建议把排序字段也加到组合索引中，放在组合索引最后列。
对较长的字符数据类型的字段建索引，优先考虑前缀索引
低选择性的列不加索引，例如”性别”，状态字段一般不加索引。例外情况是，状态数据分布很倾斜，且查询条件中没有其他更适合索引的字段，如status=1占99%数据，status=2占1%数据，查询SQL为：select col1,col2... from t where status=2;
禁止冗余索引，索引是双刃剑,会增加维护负担,增大IO压力。(a,b,c)、(a,b),后者为冗余索引。可以利用前缀索引来达到加速目的,减轻维护负担。
在建表时，应考虑需要添加什么索引，尽量避免上线后添加索引
禁用replace into和insert...on duplicate key update方式来更新主键冲突数据。
为方便增量数据和更新数据的查询，应该在update_datetime字段建立索引。如果是建立的是组合索引，则update_datetime应该在组合索引的最左边。
分库分表
如果数据有时效性，则建议按时间分表或者分区
分表的粒度应该和实际数据量结合，慎用按天分表。原则上，我们以单表1G作为分表的界限，杜绝按天分库。
如果业务必须按天分表，考虑到一个文件夹下不应存放过多文件，建议可根据年份分库，然后把按天分的表放在对应的库中。
如果所有数据热度相同，则建议根据hash或者其他手段分库分表
目前最常用的是根据分表方式是分百库十表，共1000个表。具体规则是：取分表字段(如ID)的后三位，其中后两位是库的ID(00-99)，倒数第三位是表的ID(0-9);
杜绝只按月份，不考虑年份方式分表，不同年份的数据会保存在一张表里，这种做法不利于历史数据的管理，且会降低buffer的利用率。此种情况，建议按YYYYMM方式分表。
如果多个独立业务需要共用一台DB的话，不同业务的表必须放在不同的database(schema)里，主要考虑管理便捷和安全
对于分库分表，每一个表的索引结构及名称都必须一致。
SQL
避免使用SELECT * 从数据表中读取的数据越多，查询操作速度就越慢。后期表结构的变更会导致程序不可用。
禁止使用INSERT INTO t_xxxVALUES(xxx)，必须显示指定插入的列属性容易在增加或者删除字段后出现程序BUG。
禁止大表使用JOIN查询，禁止大表使用子查询会产生临时表，消耗较多内存与CPU，极大影响数据库性能。
禁止使用OR条件，必须改为IN查询，旧版本MySQL的OR查询是不能命中索引的，新版的即使能命中索引，也会让数据库耗费更多的CPU 。
负向条件查询不能使用索引，NOT、!=、<>、!<、!>、NOT IN、NOT LIKE select * from order where status!=0 and stauts!=1 not in/not exists都不是好习惯。
前导模糊查询不能使用索引select * from order where desclike '%XX' 而非前导模糊查询则可以：select * from order where desclike 'XX%'；
数据区分度不大的字段不宜使用索引select * from user where sex=1；
mysql不支持函数索引，在属性上进行计算不能命中索引；
允许为null的列，查询有潜在大坑单列索引不存null值，复合索引不存全为null的值，请使用not null约束以及默认值。
复合索引最左前缀，并不是指SQL语句的where顺序要和复合索引一致。
如果明确知道只有一条结果返回，limit 1能够提高效率
把计算放到业务层而不是数据库层，除了节省数据的CPU，还有查询缓存优化效果
强制类型转换会全表扫描
使用ENUM而不是字符串ENUM保存的是TINYINT，别在枚举中存放一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。
两个表关联字段需要是相同的字符集，否则关联查询时不走索引
```