## 设计模式概览

### 设计模式是什么？

世界上到处都有这种模式，烹饪、艺术馆、医药、法律、数学、音乐、舞蹈等等领域。
一般来说，模式是为解决一般性经常发生类似的问题而提出的解决方案，简单来说就是一种解决方案的轮廓，但是又不仅仅于此。
用更正式的话来说，模式是对重复出现的问题的可重用解决方案的概括总览。

>软件设计模式是一般性常见问题的可复用解决方案。

在软件的开发过程中，设计模式可以很好地解决一些常见的重复出现的问题。
设计模式是解决方案的概念总览而不是解决方案本身，毕竟解决方案依赖于平台和编程语言。

### 为什么需要设计模式？

设计模式的好处：

- 设计模式已经成为了一种解决重复出现的问题的工业标准，所以使用设计模式更省时省力。
- 设计模式可以提升代码重用性，编写鲁棒性更好、维护性更好的代码。
- 因为设计模式已经定义成了标准，所以更容易理解和调试。可以加速开发，新成员也更容易理解。

### 良好的设计特性

当设计你的应用程序时，你应该需要考虑到软件设计的特性。一个伟大的设计包含所有的特性。
然而，这实际上是不可能的，因为有时一种模式与另一种模式相矛盾，所以你必须权衡，做出选择一个而不是另一个。


良好的软件设计的特性如下。

#### 易维护

软件往往是不稳定的，在未来它必然会经历维护、变化。所以软件设计需要自我扩展性较好、容易让其它程序员理解。

#### 最小复杂性

>简单是高效的灵魂。（--- Austin Freeman）

考虑简单化，一个复杂的设计往往难以扩展。有很多因素，例如很多的内部的交互和关系依赖，复杂的算法、行为规则等，都会导致设计的复杂性。

#### 松耦合

你设计时涉及到的组件都需要考虑松耦合以保持最大可能的扩展性。如果其中一个组件存在缺陷，也不会影响其他组件太多。面向对象OOP原则如封装性、信息隐藏和抽象化可以可以有效地达到目标。

#### 可移植性

可移植性是计算机程序换到另一个环境时还能继续良好工作地特性。

#### 分层和可重用性

设计模式鼓励设计可重用性。设计可重用的组件，可以供其它程序或系统使用。
例如，如果你知道安卓设计（Image）的话，提供了抽象地多布局模式。每个组件都是独立的，并且提供了很高层次地可重用性。

#### 标准技术

不要因为你不知道或不喜欢某件事而憎恨它。在你开始设计之前，进行评估和使用符合你的需求地工业化技术模式。

### GoF 设计模式

Gang-Of-Four 也称之为基础设计模式，共计23种基础设计模式，提供了软件设计中一般性常见的重复发生的问题的解决方案。
它们被分为三大主类：创造型模式、结构型模式和行为模式。

#### 创造型模式

创造型模式主要用于灵活地解决对象创建问题。可以消除对象实例化地难处，并支持在不断发展的系统中实现更高级别的重用。

| 名称        | 说明           | 
| ------------- |:-------------:| 
| 抽象工厂模式      | 提供一个创建一类关联的或者独立的对象的借口，而不需要指定它们的类 | 
| 建造者模式     | 将复杂对象的创建与表示分离开来，相同的构造过程就可以创建不同的表示了。      |  
| 工厂方法模式 | 提供了将一个对象作为一个对象工厂的方式。工厂可以根据传入数据参数返回类层级关系中的一个或者几个类实例。      |    
| 原型模式 |   通过clone已经存在的实例对象创建对象实例    |  
| 单例模式 |   在整个应用中仅仅只存在一个实例的设计模式，通常用于创建配置类实例等    |  



#### 结构型模式

结构型模式提供了对象结构和组合的问题的解决方案。可以通过简单的方式标明实体间的清晰关系。

| 名称        | 说明           | 
| ------------- |:-------------:| 
| 适配器模式      | 使用适配器将原本不相容的接口类型可以一起协同工作 | 
| 桥接模式     | 将抽象和它的实现分离开，这样两者就可以独立地变化      |  
| 组合模式 | 将对象组合成一个树的结构，表示部分-整体的层级关系。组合模式让客户端可以统一的处理单个的对象或者对象的组合   |    
| 装饰模式 |   允许动态包装对象，以修改对象已经存在的职责和行为    |  
| 门面模式 |   **为子系统的一组接口提供一个统一的接口。** 门面定义了一个使子系统更好用的更高层级的接口。   |  
| 享元模式 |   简化了对细粒度对象的重用，使得大量对象的使用更加高效    |  
| 代理模式 |   通过充当传递实体或占位符对象，允许对象级别的访问控制   |  


#### 行为模式

行为模式提供了对象间通信问题的解决方案。它们将用于管理对象之间的算法、关系和责任。

| 名称        | 说明           | 
| ------------- |:-------------:| 
| 责任链模式      | 给超过一个的对象一个机会去处理一个请求 | 
| 命令模式     | 将请求封装成一个对象，因此你可以使用不同的请求、队列或者日志请求和支持可撤销的操作参数化客户端    |  
| 拦截器模式 | 拦截请求，在处理请求之前做一些额外的处理工作   |    
| 迭代器模式 |  提供一种方法来访问聚合对象的元素，而不公开其底层的表示     |  
| 中介模式 |   通过封装不同对象集的交互和通信方式来达到松耦合，允许每个对象的操作独立。   |  
| 备忘录模式 |   捕获并外部化对象的内部状态，以便稍后可以恢复它，所有这些都不违反封装性。    |  
| 观察者模式 |   观察者模式定义了对象间的一对多的依赖关系，一个对象状态发生变化，其他所有观察者都会收到通知   |
| 状态模式 |   当对象状态发生变化时，允许其改变自身行为。对象将会改变它的类。   |
| 策略模式 |   定义了一系列的算法的封装， 以执行特定的行为  |
| 模板模式 |   定义算法的步骤，允许子类提供一个或多个步骤的实现   |
| 访问者模式 |   允许在运行时对一个或者一组对象应用一个或多个操作，从对象接口中解耦操作   |  